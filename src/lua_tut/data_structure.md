# 数据结构


Lua 中的表，不属于某种数据结构，而 *就* 是数据结构本身，tables in Lua are not a data structure; they are *the* data structure。以 Lua 中的表，咱们可以表示其他语言所提供的全部结构 -- 数组 arrays、记录 records、列表 lists、队列 queues、集合 sets 等等。此外，Lua 表还能高效地实现，全部这些结构。


在 C 和 Pascal 等传统语言中，我们会以数组和列表（列表 = 记录 + 指针），来实现大多数数据结构。虽然我们可以使用 Lua 表，来实现数组和列表（有时我们也这样做），但表要比数组和列表更强大；使用表后，许多算法都简化到了微不足道的地步。例如，我们很少在 Lua 中编写某种搜索，因为表提供了对任何类型的直接访问。


掌握如何高效地使用表，需要一点时间。本章，我们将介绍如何使用表，实现一些典型的数据结构，并举例说明其用途。我们将从数组和列表开始，这并非因为其他结构需要他们，而是因为大多数程序员已经熟悉他们。(我们已经在第 5 章 [*表*](tables.md) 中，了解了这方面的基础知识，但为了完整起见，我（作者）还是在此重复一遍。）随后，我们将继续一些更高级的示例，如集合 sets、包 bags 以及图 graphs。


## 数组

我们中简单地通过用整数索引表，来实现 Lua 中的数组。因此，数组没有固定的大小，而是根据需要增长。通常，当我们初始化数组时，我们间接地定义了其大小。例如，在以下代码之后，任何访问 1-1000 范围之外字段的尝试,都将返回 `nil`，而不是零：

```lua
local a = {}                    -- 新建数组
for i = 1, 1000 do
    a[i] = 0
end

print(#a, a[#a], a[#a + 5])     --> 1000    0       nil
```

长度运算符 (`#`) 就运用这一事实，来查找数组的大小：


```lua
print(#a)           --> 1000
```

我们可以从索引零、一或任何其他值，开始某个数组：


```lua
-- 创建一个索引为 -5 到 5 的数组
a = {}
for i = -5, 5 do
    a[i] = 0
end
```

然而，Lua 中习惯以索引一，开始数组。 Lua 库遵循了这个惯例；长度运算符也是如此。如果咱们的数组不以一开头，我们将无法使用这些设施。


我们可以使用构造器，a constructor，在单个表达式中，创建并初始化某个数组：

```lua
squares = {1, 4, 9, 16, 25, 36, 49, 64, 81}
```

这样的构造器可以很大，可以根据需要设置很多元素。在 Lua 中，有着数百万元素的数据描述文件，并不少见。


## 矩阵与多维数组

Lua 中表示矩阵的主要方法有两种。第一种是 *交错数组，jagged array*（数组的数组），即一个表，其中每个元素均为另一个表。例如，咱们可以使用以下代码，创建出维度为 **N** × **M** 的一个零的矩阵：


```lua
local mt = {}           -- 创建矩阵
for i = 1, N do
    local row = {}      -- 创建一个新行
    mt[i] = row
    for j = 1, M do
        row[j] = 0
    end
end
```

因为表属于 Lua 中的一些对象，所以我们必须显式创建出每一行，来构建出矩阵。一方面，这肯定比咱们在 C 中所做的那样，简单地声明出矩阵，更为繁琐；另一方面，其带给了我们，更多的灵活性。例如，我们可以通过将前面示例中的内部循环，更改为 `for j=1,i do ... end`，而创建出三角矩阵，a triangular matrix。此代码下，三角矩阵仅会使用原先矩阵的一半内存。

表示矩阵的第二种方式，是将两个索引，组合成一个索引。通常，我们是通过将第一个索引，乘以合适的常数，然后加上第二个索引，实现这种方式。运用这种方法，以下代码将创建出，维度为 **N** × **M** 的零的矩阵：


```lua
local mt = {}           -- 创建矩阵
for i = 1, N do
    local aux = (i - 1) * M
    for j = 1, M do
        mt[aux + j] = 0
    end
end
```

通常，应用程序会用到 *稀疏矩阵，sparse matrix*，即一种其中大多数元素为零，或 `nil` 的矩阵。例如，我们可以用其邻接矩阵，来表示某个图，represent a graph by its adjacency matrix，当节点 *m* 和 *n* 之间存在开销为 *x* 的连接时，邻接矩阵的位置 *(m,n)* 的值，便是 *x*。当这两个节点没有连接时，位置 *(m,n)* 的值,便是 *nil*。要表示一张有着一万个节点，其中每个节点大约有五个邻居的图，我们将需要有着一亿条目的矩阵（有着 10000 列和 10000 行的方形矩阵），而大约只有五万个条目，不会为零（每行五个对应着节点五个邻居的非 `nil` 列）。很多数据结构方面的书籍，都详细讨论了如何在不浪费 800MB 内存下，实现这样的稀疏矩阵，但在以 Lua 编程时，咱们很少需要这些技巧。因为我们是用表，来表示数组，所以他们自然是稀疏的。在我们的第一种表示法（表的表）下，我们将需要一万个表，每个表大约有五个元素，总共有五万个条目。在第二种表示法下，我们将有一个，其中有着五万条目的表。无论哪种表示形式，我们需要的，只是那些非 `nil` 元素的空间。

在稀疏矩阵上，咱们无法使用长度运算符（`#`），因为活动条目之间存在空洞（`nil` 值）。这并不是什么大损失；即使可以使用他，我们可能不大会使用。对于大多数操作，遍历全部这些空条目，是非常低效的。相反，我们可以使用 `pairs`，来只遍历非 `nil` 元素。作为示例，咱们来看看，如何对由交错数组表示的稀疏矩阵，完成矩阵乘法。

假设我们要将矩阵 **a[M,K]**，与矩阵 **b[K,N]** 相乘，生成矩阵 **c[M,N]**。通常的矩阵乘法算法如下：

```lua
for i = 1, M do
    for j = 1, N do
        c[i][j] = 0
        for k = 1, K
            c[i][j] = c[i][j] + a[i][k] * b[k][j]
        end
    end
end
```

两个外层循环，会遍历整个结果矩阵，而对于每个元素，那个内部循环，会计算出其值。

对于交错数组的稀疏矩阵，这个内部循环便是个问题。因为他会遍历 **b** 的列，而非行，所以我们不能在这里使用类似 `pairs` 的东西：循环必须访问每一行，查看该行是否在那个列中具有元素。与只访问少数非零元素相反，这个循环还访问了全部零的元素。 （在其他上下文中，便利列也可能是一个问题，因为其空间局部性的缺失，loss of spatial locality。）

下面的算法与前一个算法非常相似，但他颠倒了两个内部循环的顺序。通过这个简单的更改，他可以避免遍历列：

```lua
-- 假定 'c' 的全部元素均为零
for i = 1, M do
    for k = 1, K
        for j = 1, N do
            c[i][j] = c[i][j] + a[i][k] * b[k][j]
        end
    end
end
```

现在，中间那个循环遍历行了行 `a[i]`，内层循环遍历了行 `b[k]`。两个循环都可以使用 `pairs`，仅访问非零元素。所得矩阵 **c** 的初始化，在这里不是问题，因为空的稀疏矩阵，自然会用零填充。


**图 14.1，稀疏矩阵的乘法**

```lua
function Lib.mt_mult (a, b)
    local c = {}        -- 得到的矩阵
    for i = 1, #a do
        local resultline = {}                   -- 将是 'c[i]'
        for k, va in pairs(a[i]) do             -- 'va' 为 a[i][k]
            for j, vb in pairs(b[k]) do         -- 'vb' 为 b[k][j]
                local res = (resultline[j] or 0) + va * vb
                resultline[j] = (res ~= 0) and res or nil
            end
        end
        c[i] = resultline
    end
    return c
end
```

图 14.1，“稀疏矩阵的乘法” 给出了上面算法的完整实现，用到了 `pairs`，并顾及到了那些稀疏条目。这个实现只会访问那些非 `nil` 的元素，结果自然是稀疏的。此外，代码会删除偶然计算出为零的那些结果条目。
