# 位与字节

Lua 处理二进制数据的方式，类似于文本。Lua 中的字符串，可以包含任意的字节，几乎全部处理字符串的库函数，都可以处理任意的字节。对二进制数据，咱们甚至可以进行模式匹配。除此之外，Lua 5.3 还引入了一些额外的，二进制数据处理功能：除了整数外，他带来了打包和解包二进制数据的位运算符及函数。在本章中，我们将介绍，在 Lua 中处理二进制数据的这些功能，以及一些其他功能。


## 位运算符

从 5.3 版开始，Lua 就提供了一组标准的数字位运算符。与算术运算不同，位运算符只对整数值起作用。位运算符包括 `&`（位与运算 AND）、`|`（位或运算 OR）、`~`（位异或运算 exclusive-OR）、`>>`（逻辑右移）、`<<`（逻辑左移）和一元运算符的 `~`（位非运算 NOT）。(注意，在一些语言中，异或运算符是用 `^` 表示的。而在 Lua 中，`^` 是指幂运算。）

```lua
> string.format("%x", 0xff & 0xadcd)
cd
> string.format("%x", 0xff | 0xadcd)
adff
> string.format("%x", 0xaaaa ~ -1)
ffffffffffff5555
> string.format("%x", ~0)
ffffffffffffffff
```


（本章中的数个示例，都将用到 `string.format`，来以十六进制显示结果。）

全部位运算符，都工作于整数的全部位上。在标准 Lua 中，那就指的是 64 位。在实现那些假定了 32 位整数的算法（如加密哈希 SHA-2）时，这可能是个问题。不过，执行 32 位的整数操作，并不困难。除了右移运算外，在我们忽略高的一半二进制位时，在64 位上所有位操作，都与 32 位的同一操作一致。加法、减法和乘法也是如此。因此，要对 32 位整数进行运算，我们只需在右移之前，擦除整数的高 32 位即可。(我们很少在这类计算中，进行除法运算。）


两种移位运算符，都会用零填充空位。这通常称为逻辑移位。Lua 不提供算术右移，即用符号位，the signal bit，填充空位。以适当的 2 的幂的底除，a floor division（向下取整的除法），咱们就可以执行等价于算术移位的操作。(例如，`x // 16` 与算术移位四相同。）


负位移，negative displacement，会向另一方向移动，即 `a >> n` 与 `a << -n` 相同：


```lua
> string.format("%x", 0xff << 12)
ff000
> string.format("%x", 0xff >> -12)
ff000
```


如果位移等于或大于整数表示法中的位数（标准 Lua 中为 64 位，小型 Lua 中为 32 位），则结果为零，因为所有位都从结果中移出了：


```lua
> string.format("%x", -1 << 80)
0
```


## 无符号整数


整数的表示法，会用到一位来存储符号。因此，使用 64 位的整数，咱们能表示的最大整数是 <i>2<sup>63</sup> - 1</i>，而不是 <i>2<sup>64</sup> - 1</i>。通常，这种差别无关紧要，因为 <i>2<sup>63</sup> - 1</i> 已经很大了。但是，有的时候，由于我们要么要使用无符号整数，处理外部数据，要么要执行某些需要全部 64 位整数的算法，因此而不能为符号浪费一个位，此外，在小型 Lua 中，这种差异可能非常显著。例如，如果我们使用 32 位有符号整数，作为文件中的一个位置，我们的文件限制为 2 GB；而无符号整数，则会将这一限制翻倍。


Lua 并未提供对无符号整数的显式支持。不过，只要稍加注意，处理 Lua 中的无符号整数，就并不困难，我们现在就将看到这一点。

我们可以直接写出大于 <i>2<sup>63</sup> - 1</i> 的常数，尽管表面上会是下面这样：


```lua
> x = 3 << 62               --> 13835058055282163712
> x
-4611686018427387904
```

这里的问题，不在于那个常数，而在于 Lua 打印常数的方式：打印数字的标准方式，是将数字解释为有符号整数。我们可以使用 `string.format` 中的 `%u` 或 `%x` 选项，将整数视为无符号整数：


```lua
> string.format("%u", x)
13835058055282163712
> string.format("0x%X", x)
0xC000000000000000
```

由于有符号整数的表示方法（二进制补码，two's complement），有符号整数和无符号整数的加法、减法和乘法运算方式相同：


```lua
> string.format("%u", x)
13835058055282163712
> string.format("%u", x + 1)
13835058055282163713
> string.format("%u", x - 1)
13835058055282163711
```

（对于如此大的值，即使将 `x` 乘以二也会溢出，因此在这个示例中，我们没有包含该操作。）


对于有符号整数和无符号整数，排序运算符会以不同方式工作。当我们比较两个高位不同的整数时，问题就出现了。对于有符号整数，设置了该位的整数较小，因为他表示负数：


```lua
> 0x7fffffffffffffff < 0x8000000000000000
false
```


在咱们把这两个整数，都看作无符号整数时，这个结果显然是不正确的。因此，我们需要一种不同的操作，来比较无符号整数。为此，Lua 5.3 提供了 `math.ult`（*无符号小于*）：


```lua
> math.ult(0x7fffffffffffffff, 0x8000000000000000)
true
```

另一种比较的方式是，在执行有符号比较之前，先翻转两个操作数的符号位：


```lua
> mask = 0x8000000000000000
> (0x7fffffffffffffff ~ mask) < (0x8000000000000000 ~ mask)
true
```


无符号除法，也不同于有符号除法。下图 13.1 “无符号除法” 给出了无符号除法的一种算法。


**图 13.1，无符号除法**


```lua
function Lib.udiv (n, d)
    if d < 0 then
        if math.ult(n, d) then return 0
        else return 1
        end
    end

    local q = ((n >> 1) // d) << 1
    local r = n - q * d
    if not math.ult(r, d) then q = q + 1 end
    return q
end
```

第一个测试（`d < 0`），相当于测试 `d` 是否大于 <i>2<sup>63</sup></i>。在这种情况下，商只能是 1（在 `n` 等于或大于 `d` 时）或 0。否则，我们就执行将被除数除以二的等价运算，然后将结果除以除数，再将结果乘以二。其中的右移，相当于某个无符号数除以二，结果将是一个非负的有符号整数。随后的左移，纠正了商，从而撤消了之前的除法。

一般来说，`floor floor(floor(n/2)/d)*2`（这种算法所完成的计算），并不等于 `floor((n/2)/d)*2`（正确结果）。不过，不难证明两者的差异最多为一。因此，这种算法会计算除法的余数部分（在变量 `r` 中），并检查其是否大于除数：如果是，则修正商（在商上加一），这样就完成了。


将无符号整数转换为浮点数，或从浮点数转换为无符号整数，需要进行一些调整。要将无符号整数转换为浮点数，我们可以将其转换为有符号整数，然后使用求模运算符，对结果进行修正：


```lua
> u = 0xA000000000000000        --> 11529215046068469760
> f = (u + 0.0) % 2^64
> string.format("%.0f", f)
11529215046068469760
```

因为`u + 0.0` 的值为 `-6917529027641081856`，

因为标准转换，the standard conversion，会将 `u` 视为有符号整数，故 `u + 0.0` 的值为 `-6917529027641081856`。求模运算会将该值，带回到无符号整数的范围。(在实际代码中，因为浮点数的求模运算，也能完成转换，因此咱们就不需要那个加法。）

要将浮点数转换为无符号整数，我们可以使用以下代码：


```lua
> f = 0xA000000000000000.0
> u = math.tointeger(((f + 2^63) % 2^64) - 2^63)
> string.format("0x%x", u)
0xa000000000000000
```


