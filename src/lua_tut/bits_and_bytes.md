# 位与字节

Lua 处理二进制数据的方式，类似于文本。Lua 中的字符串，可以包含任意的字节，几乎全部处理字符串的库函数，都可以处理任意的字节。对二进制数据，咱们甚至可以进行模式匹配。除此之外，Lua 5.3 还引入了一些额外的，二进制数据处理功能：除了整数外，他带来了打包和解包二进制数据的位运算符及函数。在本章中，我们将介绍，在 Lua 中处理二进制数据的这些功能，以及一些其他功能。


## 位运算符

从 5.3 版开始，Lua 就提供了一组标准的数字位运算符。与算术运算不同，位运算符只对整数值起作用。位运算符包括 `&`（位与运算 AND）、`|`（位或运算 OR）、`~`（位异或运算 exclusive-OR）、`>>`（逻辑右移）、`<<`（逻辑左移）和一元运算符的 `~`（位非运算 NOT）。(注意，在一些语言中，异或运算符是用 `^` 表示的。而在 Lua 中，`^` 是指幂运算。）

```lua
> string.format("%x", 0xff & 0xadcd)
cd
> string.format("%x", 0xff | 0xadcd)
adff
> string.format("%x", 0xaaaa ~ -1)
ffffffffffff5555
> string.format("%x", ~0)
ffffffffffffffff
```


（本章中的数个示例，都将用到 `string.format`，来以十六进制显示结果。）

全部位运算符，都工作于整数的全部位上。在标准 Lua 中，那就指的是 64 位。在实现那些假定了 32 位整数的算法（如加密哈希 SHA-2）时，这可能是个问题。不过，执行 32 位的整数操作，并不困难。除了右移运算外，在我们忽略高的一半二进制位时，在64 位上所有位操作，都与 32 位的同一操作一致。加法、减法和乘法也是如此。因此，要对 32 位整数进行运算，我们只需在右移之前，擦除整数的高 32 位即可。(我们很少在这类计算中，进行除法运算。）


两种移位运算符，都会用零填充空位。这通常称为逻辑移位。Lua 不提供算术右移，即用符号位，the signal bit，填充空位。以适当的 2 的幂的底除，a floor division（向下取整的除法），咱们就可以执行等价于算术移位的操作。(例如，`x // 16` 与算术移位四相同。）


负位移，negative displacement，会向另一方向移动，即 `a >> n` 与 `a << -n` 相同：


```lua
> string.format("%x", 0xff << 12)
ff000
> string.format("%x", 0xff >> -12)
ff000
```


如果位移等于或大于整数表示法中的位数（标准 Lua 中为 64 位，小型 Lua 中为 32 位），则结果为零，因为所有位都从结果中移出了：


```lua
> string.format("%x", -1 << 80)
0
```


## 无符号整数



