# 表

**Tables**

表，是 Lua 中主要的（事实上也是唯一的）数据结构机制，data structuring mechanism，也是一种功能强大的机制。我们用表，来表示数组，arrays、集合，sets、记录，records，以及其他许多简单、统一与高效的数据结构。Lua 也使用表，来表示包，packages 和对象，objects。当我们写下 `math.sin` 时，我们想到的是“`math` 库中的函数 `sin`”。但对于 Lua 来说，这个表达式意味着“使用字符串 `"sin"` 作为键，来对表 `math` 进行索引"。

Lua 中的表，本质上是一个关联数组。表是一个，不仅可以接受数字作为索引，还可以接受字符串，或任何其他语言值（`nil` 除外）作为索引的数组。


Lua 中的表，既不是值，也不是变量，而是 *对象，objects*。如果你熟悉 Java 或 Scheme 中的数组，那么你就会明白我的意思。咱们可以将表，视为动态分配的对象，dynamically-allocated object；程序只能操作表的引用（或指针）。Lua 从不在幕后，进行隐藏复制，hidden copies，或创建新表。


我们通过 *构造表达式，constructor expression*，来创建表，而最简单的构造表达式，就是 `{}`：


```lua
> a = {}
> k = 'x'
> a[k] = 10
> a[20] = "great"
> a["x"]
10
> k = 20
> a[k]
great
> a["x"] = a["x"] + 1
> a["x"]
11
```

表始终是匿名的。保存表的变量，与表本身之间，并无固定关系：


```lua
> a = {}
> a["x"] = 10
> b = a
> b["x"]
10
> b["x"] = 20
> a["x"]
20
> a = nil
> a["x"]
stdin:1: attempt to index a nil value (global 'a')
stack traceback:
        stdin:1: in main chunk
        [C]: in ?
> b["x"]
20
```

当程序不再有着对某个表的引用时，垃圾回收器最终会删除该表，并重新使用其内存。


## 表的索引


每个表都可以存储具有不同类型索引的值，并按需要增长，以容纳新条目：


```lua
> a = {} -- 空表
> -- 创建出 1000 个新条目
> for i = 1, 1000 do a[i] = i*2 end
> a[9]
18
> a["x"] = 10
> a["x"]
10
> a["y"]
nil
```

请注意最后那行：与全局变量一样，表字段，table fields，在未初始化时，其值为 `nil`。与全局变量一样，我们也可以将表字段赋值为 `nil`，来删除他。这并非巧合： Lua 将全局变量，存储在普通表中。(我们将在第 22 章 [*环境*](the_environment.md) 中，进一步讨论这个问题。）

为表示结构（体），我们会使用字段名作为索引。Lua 通过提供 `a.name` 作为 `a["name"]` 的语法糖，来支持这种表示法。因此，我们可以用更简洁的方式，编写上一示例的最后几行，如下所示：


```lua
> a = {}
> a.x = 10
> a.x
10
> a.y
nil
```

对于 Lua 来说，这两种形式是等价的，可以自由混合。然而，对于人类读者来说，每种形式都可能表示不同的意图。点表示法清楚地表明，我们将表用作一种结构（体），其中有一组固定、预定义的键。而字符串表示法，给人的印象是，表可以有任何字符串作为键，而且出于某种原因，我们正在操作这个特定的键。


初学者常犯的错误，是混淆 `a.x` 和 `a[x]`。第一种形式表示 `a["x"]`，即以字符串 `"x"` 为索引的表。第二种形式，则是以变量 `x` 的值，为索引的表：


```lua
> a = {}
> x = 'y'
> a[x] = 10
> a[x]
10
> a.x
nil
> a.y
10
```

> **注意**：在使用非单字符、不符合变量名命名规范的字符串，作为表的索引时，就无法通过点表示法，访问到对应的字段值。使用符合变量名命名规范的字符串做表索引，仍然可以通过点表示法，访问到对应字段值。

```lua
> a = {}
> k = "index-0"
> a[k] = 1000
> a["index-0"]
1000
> a."index-0"
stdin:1: <name> expected near '"index-0"'
> a.index-0
stdin:1: attempt to perform arithmetic on a nil value (field 'index')
stack traceback:
        stdin:1: in main chunk
        [C]: in ?
> j = "index_1"
> a[j] = 2000
> a["index_1"]
2000
> a.index_1
2000
```


由于我们可以用任何类型，为表编制索引，因此在为表编制索引时，我们会遇到与相等的情形下，同样的微妙问题。虽然我们可以用数字 `0` 和字符串 `"0"`，为表编制索引，但这两个值是不同的，因此表示了表中的不同条目。同样，字符串 `"+1"`、`"01"` 和 `"1"`，也表示了不同的条目。如果对索引的实际类型有疑问，就要使用显式转换来明确：


```lua
> i = 10; j = "10"; k = "+10"
> a = {}
> a[i] = "number key"
> a[j] = "string key"
> a[k] = "another string key"
> a[i]
number key
> a[j]
string key
> a[k]
another string key
> a[tonumber(j)]
number key
> a[tonumber(k)]
number key
> a.10
stdin:1: syntax error near '.10'
> a."10"
stdin:1: <name> expected near '"10"'
```

> **注意**：表本身，也可以作为其他表的索引。

```lua
> a = {}
> b = {}
> b[a] = 1000
> a
table: 0x55c780623980
> b
table: 0x55c780623c50
> b[a]
1000
```

如果不注意这一点，就会在程序中引入微妙的错误。

整数和浮点数，不存在上述问题。与 `2` 等于 `2.0` 的相比一样，这两个值在用作键时，指的是同一个表项：


```lua
> a = {}
> a[2.0] = 10
> a[2.1] = 20
> a[2]
10
> a[2.0]
10
> a[2.1]
20
> a[2] = 30
> a[2.0]
30
```

更具体地说，在用作键时，任何可以转换为整数的浮点数值，都会被转换。例如，当 Lua 执行 `a[2.0] = 10` 时，他会将键 `2.0` 转换为 `2`。对无法转换为整数的浮点值，则会保持不变。


## 关于表构造器


构造器，是创建，及初始化表的表达式。构造器是 Lua 的一大特色，也是 Lua 最有用，和最通用的机制之一。


最简单的构造器，便是空构造器 `{}`，我们已经看到。构造器也可以初始化表。例如，下面的语句，将用字符串 `"Sunday"`，初始化 `days[1]`（构造器的第一个元素的索引为 `1`，而不是 `0`），用 `"Monday"` 初始化 `days[2]`，以此类推：


```lua
> days = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
> days[4]
Wednesday
```

Lua 还提供了一种特殊语法，来初始化类似记录的表，a record-like table，如下面的示例：


```lua
> a = {x = 10, y=20}
> a.x
10
> a['x']
10
> a['y']
20
```

前一行与这些命令等价：

```lua
> a = {}; a.x = 10; a.y = 20
```

然而，原本的表达式的速度，会更快，因为 Lua 已创建出了大小合适的表。

无论使用何种构造器，来创建表格，我们都可以在结果中，添加或删除字段：


```lua
> w = {x = 0, y = 0, label = "console"}
> x = {math.sin(0), math.sin(1), math.sin(2)}
> w[1] = "another field"
> x.f = w
> w["x"]
0
> w[1]
another field
> x.f[1]
another field
> w.x = nil             -- 移除字段 "x"
> w.x
nil
```

不过，正如我（作者）刚才提到的，使用适当的构造器，创建表除了更简洁外，效率也更高。


我们可以在同一个构造器中，混合使用记录式和列表式的初始化，record-style and list-style initializations：


```lua
> polyline = {color="blue",
>> thickness=2,
>> npoints=4,
>> {x=0,     y=0},     -- polyline[1]
>> {x=-10,   y=0},     -- polyline[2]
>> {x=-10,   y=1},     -- polyline[3]
>> {x=0,     y=1}      -- polyline[4]
>> }
> polyline
table: 0x5638dc5ecef0
```

上面的示例，还说明了我们如何嵌套表（以及构造函数），来表示更复杂的数据结构。每个 `polyline[i]` 的元素，都是一个表，代表着一条记录：

```lua
> polyline[1].x
0
> polyline[4].y
1
```


这两种构造器形式，都有其局限性。例如，我们不能用负的索引初始化字段，也不能有不具正确标识符格式的字符串索引。针对这种需要，还有另一种更通用的格式。在这种格式中，我们会明确地将每个索引，写成一个表达式，放在方括号中：


```lua
opnames = {["+"] = "add", ["-"] = "sub",
           ["*"] = "mul", ["/"] = "div"}

i = 20; s = "-"
a = {[i+0] = s, [i+1] = s..s, [i+2] = s..s..s}
```

```lua
> print(opnames[s])
sub
> print(a[22])
---
```

这种语法比较繁琐，more cumbersome，但也更灵活：正如我们在下面的等价关系中所展示的，列表样式和记录样式，都是这种更通用语法的特例：


```lua
{x = 0, y = 0}      <-->    {["x"] = 0, ["y"] = 0}
{"r", "g", "b"}     <-->    {[1] = "r", [2] = "g", [3] = "b"}
```

在最后一项后面，咱们始终可以加上逗号。这些最后的逗号是可选的，但总是有效：

```lua
> a = {[1] = "red", [2] = "green", [3] = "blue",}
> a[3]
blue
```

这种灵活性，使那些会生成 Lua 构造函数的程序，无需将最后一个元素作为特例处理（*注*：生成 JSON 代码的程序，就需要将最后一个元素，作为特列处理）。
