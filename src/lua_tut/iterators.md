# 迭代器与通用的 `for`

在本书中，我们业已用到通用的 `for`，来完成一些任务了，例如读取文件行，或遍历某个目标上的模式匹配。但是，我们仍然不知道，如何创建咱们自己的迭代器。在本章中，我们将填补这一空白。从简单的迭代器开始，我们将学习如何使用通用 `for` 的所有功能，来编写各种迭代器。


## 迭代器与闭包

所谓迭代器，是任何的允许我们遍历集合元素的结构。在 Lua 中，我们通常用函数，来表示迭代器：每次调用该函数，他都会从集合中，返回 “下一个” 元素。典型的例子，是 `io.read`：每次我们调用他时，他都会返回标准输入文件的下一行，当没有更多行要读取时，就返回 `nil`。


任何的迭代器，都需要在连续调用之间，保持某种状态，以便知道其所在位置，以及如何在那里继续前进。对于 `io.read`，C 语言在其流结构中，保留了状态。对于我们自己的迭代器来说，闭包提供了一种很好的保持状态的机制。请记住，闭包是个会访问其外层环境中，一或多个局部变量的函数。在对闭包的连续调用过程中，这些变量会保留他们的值，从而让闭包记住，他在遍历过程中所处的位置。当然，要创建新的闭包，我们就必须创建他的非局部变量。因此，闭包的结构，通常涉及两个函数：闭包本身，与一个创建出闭包及其外围变量的 *工厂，factory* 函数。


作为示例，咱们来编写一个列表的简单迭代器。与 `ipairs` 不同，这个迭代器不会返回每个元素的索引，而仅返回其值：

```lua
function values (t)
    local i = 0
    return function () i = i + 1; return t[i] end
end
```

在本例中，`values` 便是那个工厂函数。每次我们调用这个工厂，他都会创建出一个新的闭包（迭代器本身）。这个闭包会将其状态，保存在由 `values` 所创建出的，其外部变量 `t` 和 `i` 中。每次我们调用该迭代器时，他都会从列表 `t` 中，返回下一个值。


咱们可以在 `while` 循环中，使用这个迭代器：

```lua
t = {10, 20, 30}
iter = values(t)        -- 创建出迭代器

while true do
    local el = iter()   -- 调用迭代器
    if el == nil then break end
    print(el)
end
```


然而，使用通用的 `for`，会更加方便。毕竟，他就是为这类迭代设计的：

```lua
t = {10, 20, 30}
for el in values(t) do
    print(el)
end
```

通用的 `for`，完成了迭代循环的所有簿记工作：他内部保留了这个迭代器函数，因此我们不需要那个 `iter` 变量；他会为每次新的迭代，调用该迭代器；当迭代器返回 `nil` 时，他就停止循环。(在下一节中，我们将看到通用的 `for` 所做的，还不止这些。）


作为一个更高级的示例，下图 18.1，“遍历标准输入中所有单词的迭代器”，给出了一个遍历标准输入中，所有单词的迭代器。


```lua
function allwords ()
    local line = io.read()          -- 当前行
    local pos = 1                   -- 行中的当前位置

    return function ()              -- 迭代器函数
        while line do               -- 在存在行期间重复
            local w, e = string.match(line, "(%w+)()", pos)
            if w then               -- 发现了一个单词？
                pos = e             -- 下一位置是在这个单词之后
                return w            -- 返回这个单词
            else
                line = io.read()    -- 未找到单词；尝试下一行
                pos = 1             -- 从首个位置重新开始
            end
        end
        return nil                  -- 不再有行：遍历结束
    end
end
```

为了完成这个遍历，我们保留了两个值：当前行的内容（变量 `line`），即我们在这一行的位置（变量 `pos`）。有了这些数据，我们就总是可以生成下一个单词。其中迭代器函数的主要部分，是调用 `string.match`，从当前位置开始，检索出当前行中的单词。他使用了模式 `"%w+"`，描述某个 “单词”，该模式会匹配一或多个字母数字的字符。如果找到某个单词，他将捕获并返回该单词，以及其后第一个字符的位置（以一个空捕获）。然后，该函数会更新当前位置，并返回这个单词。否则，迭代器将读取一个新行，并重复检索。如果不再有行，则返回 `nil`，表示该迭代的结束。

> **译注**：根据 [简单 I/O 模型](external.md#简单-io-模型)，这个迭代器工厂的使用，要在 `io.input("filename")` 的上下文中。

尽管其具有一定复杂度，但 `allwords` 的使用，却很简单：


```lua
for w in allwords() do
    print(w)
end
```

这便是迭代器下的常见情况：他们可能不容易编写，但却很容易使用。这并不是什么大问题；通常，以 Lua 编程的最终用户，不会定义迭代器，而只是使用由应用所提供的那些迭代器。


## 通用 `for` 的语义

**The Semantics of the Generic `for`**

前面那些迭代器的一个缺点是，我们需要创建出一个新的，用来初始化每个新循环的闭包。在很多情况下，这并不是一个真正的问题。例如，在那个 `allwords` 迭代器中，创建出一个闭包的成本，与读取整个文件的成本相比，可以忽略不计。不过，在某些情况下，这种开销会带来不便。在这种情况下，我们可以使用通用的 `for` 本身，来保留迭代状态。在本节中，我们将看到，通用的 `for`，为保持状态所提供的便利。


我们曾看到过，在循环过程中，通用 `for` 会在内部，保留着迭代器函数。实际上，他保留了三个值：迭代器函数、某种 *不变状态，invariant state* 及 一个 *控制变量，control variable*。现在咱们来看看细节。


通用 `for` 的语法如下：


```lua
for var-list in exp-list do
    body
end
```

其中，<code><i>var-list</i></code> 是个用逗号分隔的，一或多个变量的列表；<code><i>exp-list</i></code> 是个也用逗号分隔的，一或多个表达式的列表。表达式列表通常只会有一个元素，即对某个迭代器工厂的调用。例如，在下面的代码中，变量列表是 `k,v`，而表达式列表，则只有一个元素 `pairs(t)`：


```lua
for k, v in pairs(t) do print(k, v) end
```

我们将 `var-list` 列表中的第一（或唯一一个）变量，称为 *控制变量，control variable*。在循环过程中，他的值永远不会为 `nil`，因为当其成为 `nil` 时，循环就结束了。

`for` 所做的第一件事，是求得 `in` 后面表达式的值。这些表达式，应产生由 `for` 所保留的三个值：迭代器函数、不变状态与控制变量的初始值。与 [多重赋值](functions.md#多个返回值) 一样，只有列表中的最后一个（或唯一一个）元素，才可以产生一个以上的值；并且值的数量，会被调整为三个，多余的值会根据需要，丢弃或添加 `nil`。例如，在我们使用简单迭代器时，迭代器工厂就只会返回迭代器函数，因此不变状态和控制变量，均会得到 `nil`。


在这个初始化步骤之后，`for` 会以两个参数，调用迭代器函数：不变状态与控制变量。从 `for` 结构的角度来看，不变状态没有任何意义。`for` 只会将初始化步骤中的那个状态值，传递给迭代器函数的所有调用。然后，`for` 将迭代函数返回的值，赋值给其变量列表中声明的那些变量。如果返回的第一个值（分配给控制变量的那个）为 `nil`，循环就会终止。否则，`for` 就会执行其主体，并再次调用迭代函数，重复循环过程。

更确切地说，像下面这种结构

```lua
for var_1, ..., var_n in explist do block end
```

与下面的代码等价：

```lua
do
    local _f, _s, _var = explist
    while true do
        local var_1, ..., var_n = _f(_s, _var)
        _var = var_1
        if _var == nil then break end
        block
    end
end
```

因此，在咱们的迭代函数是 *f*，不变状态是 *s*，控制变量的初始值是 *a<sub>0</sub>* 时，那么控制变量将循环使用 *a<sub>1</sub> = f(s,a<sub>0</sub>)*、*a<sub>2</sub> = f(s,a<sub>1</sub>)* 等值，直到 *a<sub>i</sub>* 为 `nil`。如果 `for` 还有其他变量，他们则只需获得每次调用 *f* 时，所返回的额外值。
