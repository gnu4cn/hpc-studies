# 迭代器与通用的 `for`

在本书中，我们业已用到通用的 `for`，来完成一些任务了，例如读取文件行，或遍历某个目标上的模式匹配。但是，我们仍然不知道，如何创建咱们自己的迭代器。在本章中，我们将填补这一空白。从简单的迭代器开始，我们将学习如何使用通用 `for` 的所有功能，来编写各种迭代器。


## 迭代器与闭包

所谓迭代器，是任何的允许我们遍历集合元素的结构。在 Lua 中，我们通常用函数，来表示迭代器：每次调用该函数，他都会从集合中，返回 “下一个” 元素。典型的例子，是 `io.read`：每次我们调用他时，他都会返回标准输入文件的下一行，当没有更多行要读取时，就返回 `nil`。


任何的迭代器，都需要在连续调用之间，保持某种状态，以便知道其所在位置，以及如何在那里继续前进。对于 `io.read`，C 语言在其流结构中，保留了状态。对于我们自己的迭代器来说，闭包提供了一种很好的保持状态的机制。请记住，闭包是个会访问其外层环境中，一或多个局部变量的函数。在对闭包的连续调用过程中，这些变量会保留他们的值，从而让闭包记住，他在遍历过程中所处的位置。当然，要创建新的闭包，我们就必须创建他的非局部变量。因此，闭包的结构，通常涉及两个函数：闭包本身，与一个创建出闭包及其外围变量的 *工厂，factory* 函数。


作为示例，咱们来编写一个列表的简单迭代器。与 `ipairs` 不同，这个迭代器不会返回每个元素的索引，而仅返回其值：

```lua
function values (t)
    local i = 0
    return function () i = i + 1; return t[i] end
end
```

在本例中，`values` 便是那个工厂函数。每次我们调用这个工厂，他都会创建出一个新的闭包（迭代器本身）。这个闭包会将其状态，保存在由 `values` 所创建出的，其外部变量 `t` 和 `i` 中。每次我们调用该迭代器时，他都会从列表 `t` 中，返回下一个值。


咱们可以在 `while` 循环中，使用这个迭代器：

```lua
t = {10, 20, 30}
iter = values(t)        -- 创建出迭代器

while true do
    local el = iter()   -- 调用迭代器
    if el == nil then break end
    print(el)
end
```


然而，使用通用的 `for`，会更加方便。毕竟，他就是为这类迭代设计的：

```lua
t = {10, 20, 30}
for el in values(t) do
    print(el)
end
```

通用的 `for`，完成了迭代循环的所有簿记工作：他内部保留了这个迭代器函数，因此我们不需要那个 `iter` 变量；他会为每次新的迭代，调用该迭代器；当迭代器返回 `nil` 时，他就停止循环。(在下一节中，我们将看到通用的 `for` 所做的，还不止这些。）


作为一个更高级的示例，下图 18.1，“遍历标准输入中所有单词的迭代器”，给出了一个遍历标准输入中，所有单词的迭代器。


```lua
function allwords ()
    local line = io.read()          -- 当前行
    local pos = 1                   -- 行中的当前位置

    return function ()              -- 迭代器函数
        while line do               -- 在存在行期间重复
            local w, e = string.match(line, "(%w+)()", pos)
            if w then               -- 发现了一个单词？
                pos = e             -- 下一位置是在这个单词之后
                return w            -- 返回这个单词
            else
                line = io.read()    -- 未找到单词；尝试下一行
                pos = 1             -- 从首个位置重新开始
            end
        end
        return nil                  -- 不再有行：遍历结束
    end
end
```

为了完成这个遍历，我们保留了两个值：当前行的内容（变量 `line`），即我们在这一行的位置（变量 `pos`）。有了这些数据，我们就总是可以生成下一个单词。其中迭代器函数的主要部分，是调用 `string.match`，从当前位置开始，检索出当前行中的单词。他使用了模式 `"%w+"`，描述某个 “单词”，该模式会匹配一或多个字母数字的字符。如果找到某个单词，他将捕获并返回该单词，以及其后第一个字符的位置（以一个空捕获）。然后，该函数会更新当前位置，并返回这个单词。否则，迭代器将读取一个新行，并重复检索。如果不再有行，则返回 `nil`，表示该迭代的结束。
