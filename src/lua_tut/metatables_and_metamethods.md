# 元表与元方法

**Metatables and Metamethods**


通常，Lua 中的每个值，都有一套相对可预测的操作。我们可以把数字相加，可以连接字符串，可以将键值对，插入表等等。但是，我们不能把表相加，不能把函数作比较，也不能调用字符串。除非我们使用元表。


元表允许我们在某个值面临某种未知操作时，改变其行为。例如，运用元表，我们可以定义 Lua 如何计算表达式 `a + b`，其中 `a` 和 `b` 是表。每当 Lua 尝试将两个表相加时，他都会检查两个表之一，是否有个 *元表，metatable*，以及元表是否有个 `__add` 字段。如果 Lua 找到了这个字段，他就会调用相应的值 -- 即所谓的 *元方法，metamethod*，其应是个计算和的函数。


我们可以把元表，看作面向对象的术语体系中，一种受限制的类。与类一样，元表定义了其实例的行为。不过，元表比类更受限，因为他们只能将行为赋予给一组预定义操作；同时，元表不具有继承性。不过，我们将在第 21 章，[面向对象编程](oop.md) 中，看到如何在元表的基础上，构建出一种相当完整的类系统。


Lua 中的每个值，都可以有个元表。表和用户数据，都有各自的元表；其他类型的值，则共享该类型全体值的单个元表。Lua 总是会创建出，不带元表的新表：



```lua
t = {}
print(getmetatable(t))      --> nil
```

我们可以使用 `setmetatable`，来设置或更改某个表的元表：


```lua
t1 = {}
setmetatable(t, t1)
assert(getmetatable(t) == t1)
```

在 Lua 中，我们只能设置表的元表；要操作其他类型值的元表，我们必须使用 C 代码，或调试库。(这一限制的主要原因，是为了限制宽类型元表的过度使用，to curb excessive use of type-wide metables。一些老版本 Lua 的经验表明，这些全局设置，经常会导致不可重用的代码。）字符串库为字符串设置了元表；所有其他类型，默认情况下，均无元表：


```lua
print(getmetatable("hi"))               --> table: 000002634fa4aea0
print(getmetatable("xuxu"))             --> table: 000002634fa4aea0
print(getmetatable(10))                 --> nil
print(getmetatable(print))              --> nil
```
