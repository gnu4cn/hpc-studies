# 数字

到 5.2 版为止，Lua 均使用双精度浮点格式，表示所有数字。从 5.3 版开始，Lua 使用了两种不同数字表示法： 64 位整数（简称 *整数，integers*）和双精度浮点数（简称 *浮点数，floats*）。(请注意，在本书中，“浮点数，float” 一词不意味着单精度，single precision。）对于受限平台，我们可以将 Lua 5.3 编译为 *Small Lua*，他会使用 32 位的整数，和单精度浮点数。


> **注**：我们使用与标准 Lua 相同的源文件，创建 Small Lua，只是编译时，定义了宏 `LUA_32BITS`。除了数字表示的大小外，Small Lua 与标准 Lua 完全相同。


整数的引入，是 Lua 5.3 的标志，也是其与之前版本 Lua 的主要区别。尽管如此，这一变化几乎没有造成兼容问题，因为双精度浮点数，可以精确表示 2^53 以内的整数。我们在此介绍的大部分内容，也适用于 Lua 5.2 以及更旧的版本。在本章最后，我将详细讨论兼容问题。


## 数值

**Numerals**


在书写数字常量时，咱们可以选择使用小数部分，以及小数指数，比如下面的例子：


```lua
> 4
4
> 0.4
0.4
> 4.57e-3
0.00457
> 0.3e12
300000000000.0
> 5E+20
5e+20
```


带小数点或指数的数字，会被视为浮点数，否则被视为整数。

整型值和浮点型值的类型，都是 `"number"`：


```lua
> type(3)
number
> type(3.5)
number
> type(3e-3)
number
```


他们之所以具有相同类型，是因为他们通常可以互换。此外，具有相同值的整数和浮点数，在 Lua 中的比较结果是相等的：


```lua
> 1 == 1.0
true
> -3 == -3.0
true
> 0.2e3 == 200
true
```


在极少数需要区分浮点数和整数的情形下，咱们可以使用 `math.type`：


```lua
> math.type(3)
integer
> math.type(3.0)
float
```


此外，Lua 5.3 会以不同的方式，显示他们：


```lua
> 3
3
> 3.0
3.0
> 1000
1000
> 1e3
1000.0
```

与许多其他编程语言一样，Lua 也支持十六进制的常数，hexadecimal constants，只需在常数前加上 `0x`。与许多其他编程语言不同，Lua 还支持浮点的十六进制常量，这种常量可以有小数部分，以及二进制的指数，前缀为 `p` 或 `P`<sup>2</sup>。下面的示例，演示了这种数字格式：


> *注 2*：此特性是 Lua 5.2 中引入的。


```lua
> 0xff
255
> 0x1A3
419
> 0x0.2
0.125
> 0xa.bp2
42.75
> 0x1p-1
0.5
> 0xa.b
10.6875
> 10.6875 * 4
42.75
>
> 0xa.bp2 == 0xa.bP2
true
```


使用带有 `%a` 选项的 `string.format` 函数，Lua 便可写出这种格式的数字：


```lua
> string.format("%a", 419)
0x1.a3p+8
> 0x1.a3
1.63671875
> 419 / 0x1.a3
256.0
> 0x1p+8
256.0
> string.format("%a", 0.1)
0x1.999999999999ap-4
```

虽然这种格式对人类不太友好，但他保留了浮点数值的全部精度，而且转换速度比十进制数更快。


## 算术运算符

Lua 提供了常用的那套算术运算符：加、减、乘、除和取反，negation（一元减号）。他还支持取整除法，floor division、求模，modulo 以及求幂，exponentiation。

Lua 5.3 中引入整数的主要指导原则之一，便是 *“程序员可能会选择忽略整数和浮点数之间的差异，或者完全控制每个数字的表示”*<sup>3</sup>。因此，任何的算术运算符，都应该在处理整数和实数时，给出同样的结果。


> *注 3*：摘自 Lua 5.3 参考手册。
